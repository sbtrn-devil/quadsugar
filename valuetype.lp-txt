#LP-include valuetype-inc.lp-txt
#-LP

#LP M/main-doc { <#./%title: ValueType#>

ValueType (VT) is a JavaScript library focused on idea of value-type objects that can be compared and used as map keys using value-equality comparison logic.

It comes packaged with Quadsugar, but is technically independent, so can be easily debundled and used on its own.

#LP ./vt-intro { <#./%title: Introduction#> <#./%order: 1#>

One of challenges with standard JavaScript built-in `Map` and `Set` classes is that they only allow primitive values and objects compared by reference as the keys.
Maps keyed by e. g. a tuple or a dictionary-type record is not possible on built-in basis and can only be achieved via various miserable contortions.

There have been various EcmaScript proposals on improving this (e. g.: [Value Types](https://github.com/tschneidereit/typed-objects-explainer/blob/master/valuetypes.md) (do not mistake for our VT),
[Immutable Data Structures](https://github.com/sebmarkbage/ecmascript-immutable-data-structures), [Composites](https://github.com/tc39/proposal-composites)), they are all either declined or still in the process
(as of end of 2025) and suffer from varying degrees of incompleteness.

Based on "let's not wait for nature's favors" consideration, our VT library offers another take on the problem, right away practical and with a slightly different approach than all of the above. It does not
require any extra syntax or polyfills on top of standard ES 2019, and utilises some JIT-alike approach under the hood (some JS code generated on demand, attempting to address performance side of the problem).

VT can be used both in browser environment:
```
...
<script src="https://sbtrn-devil.github.io/quadsugar/valuetype-1.0.0.js"></script>
<!-- but better download it and put nearby, or even paste inline, in order to reduce external depencencies and prevent leftpad-like conditions -->
...
<script>
// here you can already see the outline of the idea
var v = ValueType.New `{ x: ${1}, y: ${2} }`;
var map = new ValueType.MapVTK();
map.set(v, "42");
console.log(map.get(v));
console.log(map.get(ValueType.New `{ x: ${1}, y: ${2} }`));
</script>
```

and in Node.js environment (within Quadsugar package):
```
# from gitverse
npm install git+https://gitverse.ru/mikle33/quadsugar

# or: from github
npm install git+https://github.com/sbtrn-devil/quadsugar
```

Then, in a CommonJS style module:

```
const ValueType = require('quadsugar/valuetype');

var v = ValueType.New `{ x: ${1}, y: ${2} }`;
...
```

#LP ./what-it-is-and-is-not { <#./%title: What it is and is not#>


VT is designed with the most specific need in mind: ability to have map with composite keys of known-ahead structure and to simplify specification of such keys. That doesn't mean it can't be used creatively
for other purposes, but one should understand the library design goals, the resulting limitations and seeming inconveniences for particular use cases.

Specifically, we would like to warn in advance against sevaral most obvious misuses:

- Using VT for constructing arbitrarily complex immutable data which is then meant to pass around for general purposes.

No, this is totally not what it is tailored for. Usage of VT objects should only be restricted to map keys and passing around as such, and the variety of map key structures should be kept to a reasonable minimum.
Data immutability is not an end in itself, but rather a forced measure for consistency in the intended use case.
If you mean other cases involving immutable data, it is better to resort to more dedicated libraries for them. Or, which is better and more appropriate for JS, reconsider necessity in these cases at all. Data
immutability is a part of __Functionally Anti Programming Cargo Cult (FAPCC)__, which is a bane of modern programming, and of JS programming specifically.

- Using VT objects as source and target for serialization/deserialization of various inputs/outputs.

Trying this, you will probably notice these objects handling are quite inconvenient from this use case perspective. That's because it is, similarly to above, not an intended use case.

#LP } <-#./what-it-is-and-is-not#>

#LP } <-#./vt-intro#>

#LP ./value-types { <#./%title: Value-type concepts#> <#./%order: 2#>

A __value-type value__ is either a primitive value (`undefined`, `null`, boolean, string, number, bigint, symbol), or a __value-type object__ (VTO), that is an array or an object that meets the following requirements:
- its shallow schema (that is, the set of its own property keys, and whether the object is an array) is fixed and frozen during the object's lifetime, and preferably is known or predictable statically,
- it is qualified as a VTO.
The values by VTO's keys may in turn be, or may be not, value-type values. Note that only string and numeric keys are allowed in VTOs (no symbol keys), with numeric keys only allowed in array-type VTOs and
string keys only allowed in non-array VTOs, and mixing string and numeric keys within the same VTO is not allowed.

The "qualified as a VTO" point is important: an object created just by `Object.freeze({ key: value })` does not automatically become a VTO. In fact, VTOs can only be created in a few specific ways,
which we'll discuss a bit later.

Value-type values are meant to be compared by __value-type equality__:
- a primitive value or a non-VTO is value-type equal to another value (value-type or not) if they are equal per JS `===` operator (that is, non-VTO objects are value-type equal only to themselves),
- a VTO is equal to another value if:
    - the other value is also a VTO,
    - they have same shallow schema (that is, their sets of own keys are equal as unordered sets),
    - values by each key in their shallow schemas are correspondingly equal per value-type equality.

#LP } <-#./value-types#>

#LP ./value-types-creation { <#./%title: Value-type objects creation#> <#./%order: 3#>

The VTOs can be created with several methods that are inherently and intentionelly different from creating "plain" JS objects.

## Construction literals

The basic way of creating VTOs is via tagged string template literals:

```
var xy = ValueType.New `{ x: ${10}, y: ${20} }`; // an { x: 10, y: 20 } VTO
var xy2 = ValueType.New `{ "x": ${10}, "y": ${20} }`; // same as above. The ID keys are actually strings, similarly to JS literal objects.
var arr = ValueType.New `[0: ${"a"}, 1: ${100}]`; // an array VTO with 2 entries
var arr2 = ValueType.New `[0: ${"a"}, 2: ${200}]`; // some indexes in array can be omitted, they will not exist as keys
var arr3 = ValueType.New `[${"a"}, ${100}]`; // for array with continuous span of indexes starting from 0, there is a shortcut
```
(These strings are also called "schemas", more specifically "set schemas", as there are other types of schemas too.)

Actually the `:`s, `,`s (and also `...`s, which we'll encounter a bit later) are ignored (as well as whitespaces and single/multi line JS style comments),
so you could just rewrite the above literals more concisely:
```
ValueType.New `{ x ${10} y ${20} }`;
ValueType.New `{ "x" ${10} "y" ${20} }`;
ValueType.New `[0 ${"a"} 1 ${100}]`;
ValueType.New `[0 ${"a"} 2 ${200}]`;
ValueType.New `[${"a"} ${100}]`;
```
but for sake of readability it might be better to keep the decoration.

From user and JS perspective, the objects are just plain frozen JS objects:

```
console.log(xy.x, xy.y); // 10 20
console.log(arr[1]); // 100
console.log(Object.keys(arr2)); // ['0', '2']
```

Nevertheless, they are qualified as VTOs. It can be checked by `ValueType.isValueTypeObject` method:
```
console.log(xy); // true
console.log(ValueType.New `{ x: ${10}, y: ${20} }`); // true
console.log({ x: 10, y: 20 }); // false
```

Note that VTO status and immutability does not automatically spread to nested objects:
```
var testVTO = ValueType.New `{ v: ${{ x: 1, y: 2 }} }`;
console.log(ValueType.isValueTypeObject(testVTO)); // true
console.log(ValueType.isValueTypeObject(testVTO.v)); // false
testVTO.v.x = 100; // ok
```

But you can do the following:
```
var testVTO2 = ValueType.New `{ v: ${ValueType.New `{ x: ${1}, y: ${2} }`} }`;
```

However, if you need to deal with VTOs that span more than one nesting level, it is more practical to do this directly in the schema:
```
var testVTO2 = ValueType.New `{ v: { x: ${1}, y: ${2} } }`;
// it is also possible to specify the same using a destructuring subschema:
var testVTO2 = ValueType.New `{ v: @{x,y} ${{x: 1, y: 2}} } }`;
```

Thus, a VTO structure can be quite complex:
```
ValueType.New `{ name: ${"Username"}, date: [${2025} ${11} ${16}], mutableEntity: ${new Object()} }`;
```
But don't abuse this without necessity: remember that VTOs are primarily meant to be used as map keys.

## Modification literals

Another way to create VTOs is by modifying existing VTOs. It is done via edit schemas:
```
var value1 = ValueType.New `{ y: { a: ${20}, b: ${30} }, z: ${40}, w: ${{ id: "non-VTO" }} }`;

var value2 = ValueType.From(value1) `+{ x: [${10}, ${15}], y: +{ b: ${31} }, -z }`;
```
In this example, `value2` is constructed based on `value1` using the following modifications:

- member `x` is added (or replaced if one existed in the original object) with the VTO array `[10, 15]`,
- member `y` is modified according to the nested modification schema,
- member `z`, if any existed in the original, is deleted,
- unreferenced members (namely `w`) remain as they were in the original.

Modification schema can be arbitrarily nested (but not inside set schema/sub-schema, where it just does not make sense). The nested modification schemas works the same as the main one - here,
the `y` is modified in the following way:
- sub-member `b` is added/replaced with the value of `31`,
- sub-member `a` remains as is.

Note that if the modification schema (prefixed with `+`) is applied to a (sub-)member, it is required to exist, to be a VTO, and to be of matching array/non-array type to the modification schema. Thus:
```
ValueType.From(value1) `+{ c: +{ d: ${1} }`; // error: there is no value1.c
ValueType.From(value1) `+{ w: +{ v: ${2} }`; // error: value1.w is a non-VTO
ValueType.From(value1) `+{ y: +[2: ${3}] }`; // error: value1.y is a VTO, but is not an array
ValueType.From(value1) `+{ y: +{ +b: { b1: ${2} } }`; // error: value1.y.b is not an object
```
A mismatch between the original value against the modification schema will result in runtime error thrown.

Since a VTO is immutable, result of the `ValueType.From` literal is always a new object, although its unmodified VTO-members can remain copied by reference.

## Destructuring schemas and subschemas

If a VTO has some intricate, repetitive or verbose structure, or has a widely used mutable counterpart with frequent casts from or to, another way of creating them may be practical -
by using pre-declared destructuring schemas.

```
var schVec = ValueType.Schema `{ x, y, z[0, 1] }`; // a VTO that consists of members x, y, and z, where z is an array-type VTO that consists of 2 indexes 0 and 1
```
Then schema can be used to create a VTO from destructuring a JS object:
```
var vecVal = schVec.valueFrom({ x: 1, y: { text: "non-VTO" }, z: [10, 20] });
// same as: ValueType.New `{ x: ${1}, y: ${{ text: "non-VTO" }}, z: [0: 10, 1: 20] }`;
```

A schema must be __fit__ by the destructured object: all of the referenced members and sub-members must exist.
```
schVec.valueFrom({ x: 1, y: 2 }); // incorrect: destructured object has no z member
```
Compliance failure will result in runtime error thrown.
Schema object has `.fits` method that allows to test in advance whether an object fits it:
```
schVec.fits({ x: 1, y: 2, z: [3, 4] }); // true
schVec.fits({ x: 1, y: 2 }); // false: no z
schVec.fits({ x: 1, y: 2, z: [3, 4], w: "yes" }); // true: extra members are allowed, they will be ignored on destructuring
```

A schema can be referenced as part of another destructuring schema (an external (sub-)schema):
```
var schVec2 = ValueType.Schema `{ x, y }`;
var schItem = ValueType.Schema `{ id, position: @${schVec2} }`;
var itemValue = schItem.fromValue({ id: "111", position: { x: 1, y: 2 }});
```

It also can be used to specify a member by inline destructuring via the external schema inside a set/edit schema:
```
var position = { x: 1, y: 2 };
var valueWithVec2 = ValueType `{ main: ${100}, position: @${schVec2} ...${position} }`;
```
Actually it is possible to specify the member destructuring (sub-)schema right inline:
```
var valueWithVec2 = ValueType `{ main: ${100}, position: @{x,y} ...${position} }`;
```
But, unlike in declaration via `ValueType.Schema`, inline schemas are not allowed to reference sub-sub-schemas:
```
ValueType `{ item: @{id,@${schVec2}} ...${position} }`; // DISALLOWED
```
An inline schema must be either entirely external, or entirely inline. Also, it is only possible to use a schema for adding/replacing a member, not for editing inside it.

Pre-declared destructuring schemas do not introduce any new types - it is just a convenience tool to reduce duplication of set schema expressions in repetivive casts between
VTO and their non-VTO counterparts. All that matters is the set of members and the structure they make up.
Schemas that expand to the same set of members deliver exactly the same VTO structures, and the same as the same set of members directly listed inline in a set schema.

#LP } <-#./value-types-creation#>

#LP ./value-types-operations { <#./%title: Value-type values operations#> <#./%order: 4#>

Value-type values are subject to value-type specific operations.

## Value-type equality check

`ValueType.equals(v1, v2)` returns true if (and false unless) `v1` and `v2` are value-type equal, in the definition of value-type equality as stated in <#ref M/main-doc/value-types#>.
In contexts that assume use of value-type values, you should always use value-type equality comparison, as value-type equal objects may or may be not equal by JS identity.

By definition, order of the keys in VTO construction schemas and method of their specificaiton does not matter - only the set of keys and their values:
```
ValueType.equals(ValueType.New `{ x: ${1}, y: ${2} }`, ValueType.New `{ y: ${2}, x: ${1} }`); // true
ValueType.equals(ValueType.New `[${"a"}, ${"b"}]`, ValueType.New `[0: ${"a"}, 1: ${"b"}]`); // true
ValueType.equals((ValueType.Schema `{a, b}`).fromValue({ a: 3, b: 4 }), ValueType.New `{a: ${3}, b: ${4}}`); // true

// and only if they are actually different...
ValueType.equals(ValueType.New `{ x: ${1}, y: ${2} }`, ValueType.New `{ x: ${1}, y: ${3} }`); // false (has a member with a different value)
ValueType.equals(ValueType.New `{ x: ${1}, y: ${2} }`, ValueType.New `{ x: ${1}, y: ${2}, z: ${3} }`); // false (has extra key)
```
Note that, when determining set of keys, a key explicitly set to `undefined` is not the same as an undefined key:
```
ValueType.equals(ValueType.New `{ x: ${undefined}, y: ${1} }`, ValueType.New `{ y: ${1} }`); // false!
```

## Value-type ordering comparison

In case when it is required, for some reason, to sort value-type values, you can use `ValueType.comparator(v1, v2)`. It returns a negative value if `v1` is 'less' than `v2`, a positive value
if `v1` is 'greater' than `v2`, or 0 if they are 'equal'.

The comparator uses a slightly relaxed notion of equality compared to value-type equality: specifically, non-VTO objects are considered equal to each other. If, however, you need a strict total ordering
(at cost of some performance and increased footprint), you can add a third argument with non-false falue: `ValueType.comparator(v1, v2, true)`. This enforces string ordering between _any_ values.

Note that the order introduced by `ValueType.comparator`, with or without 3rd parameter, is intentionally private and only holds within the current JS context - it is does not persist and is not
guaranteed to be consistent between different reloads of same page or Node.js runs. Therefore, you should not rely on assumptions about two values will be in a particular specific order, other than
it will be a consistent order within the current JS context.

## Checking if a value is value-type

`ValueType.isValue(v)` method returns true if (or false unless) `v` is a value-type value:
```
ValueType.isValue(ValueType.New `{ x: ${1} }`); // true
ValueType.isValue(null); // true
ValueType.isValue(1); // true
ValueType.isValue("blarg"); // true
ValueType.isValue({ x: 1 }); // false (a non-VTO)
ValueType.isValue(() => 1); // false (functions are non-VTO)
```

In case if you need to check that the value is not just a value-type, but specifically a VTO, use `ValueType.isValueTypeObject(v)`:
```
ValueType.isValueTypeObject(null); // false
ValueType.isValueTypeObject(10); // false
ValueType.isValueTypeObject({ x: 1 }); // false
ValueType.isValueTypeObject(ValueType.New `{ x: ${1} }`); // true
```

## Getting a mutable copy

`ValueType.toMutable(o)` delivers a mutable clone of `o` if it is a VTO, or the `o` itself otherwise. The cloning is shallow, that is, only spans the 1st level of the keys:

```
var srcObj = ValueType.New `{ x: ${1}, y: { a: ${2}, b: ${3} } }`;
var mutObj = ValueType.toMutable(srcObj);
mutObj.x++; // ok
mutObj.y.a++; // FAIL: mutObj.y is still a VTO
// you will need to do this:
mutObj.y = ValueType.toMutable(mutObj.y);
mutObj.y.a++; // now it works
```

There intentionally is no method for deep mutable cloning, as there is no consistent convention on how to proceed through nodes that are non-VTO objects, and in most cases the valid option
is very use-case specific - so it is up to the user to implement the particular method if needed. `ValueType.toMutable(o)` can be used as a building block.

## Value-type keyed map

Built-in JS `Map` and `Set` are not aware of value-type values and won't handle them correctly. VT provides a drop-in implementation of `Map` that you should use instead: <#ref main-doc/map-vtk#>

#LP } <-#./value-types-operations#>

#LP ./map-vtk { <#./%title: MapVTK#> <#./%order: 5#>

`MapVTK` (VTK stands for Value-Type Keys) is counterpart of `Map` that can handle value-type keys. It contains the same methods as standard `Map` (plus several extras), and behaves exactly the same
as standard `Map` when keys are primitive or non-VTO.

For VTO keys, the complexity of `MapVTK` read/write operations is O(x*k), where x is complexity of such operations in standard `Map` (usually O(1)), and k is cardinality of the VTO object (the amount of
end nodes, from top of the structure down to primitive and non-VTO values, plus number of nested VTO objects in the way) used as the key in the operation. For example, for `{ x: ${1}, y: [${2}, ${3}] }` k = 3
(terminal values) + 1 (the top level `{x,y}`) + 1 (`[0,1]` at `y`) = 5, so the operation on this key will be ~O(5). It is a motivation to use simpler and flatter keys.

VT only provides counterpart to the `Map`, but not to the `Set`. The reason being, a set is quite easily implemented on top of map, especially with JS `Set` interface which is nearly identical to `Map`.

#LP } <-#./map-vtk#>

#LP ./quadsugar-bonus { <#./%title: Quadsugar bonus#> <#./%order: 6#>

VT is independent from Quadsugar, but it can provide some bonuses if you use them together.

```
QUADSUGAR
.useStaticTags({
	...ValueType.quadsugarTags(QUADSUGAR, {
		New: "VT.New", // static tag to use as shortcut to ValueType.New
		From: "VT.From", // static tag to use as shortcut to ValueType.From
		Schema: "VT.Schema", // static tag to use as shortcut to ValueType.Schema
		$: "VT." // static tag to use for VT custom algebra expressions
	})
})
.wrap(() => {
	var schXY = "VT.Schema" `{x, y}`;
	var v1 = "VT.New" `{ x: ${1}, y: ${2} }`,
		v2 = schXY.fromValue({ x: 1, y: 2 }),
		v3 = "VT.From"(v2) `+{ x: ${3} }`;
	// QS static tags produce back-end code that is slightly more performant in loops than via standard JS string tags

	// the VT custom algebra features == and != operators for comparison by value-type equality
	if ("VT." `${v1} == ${v2}`) console.log("v1 equals v2");
	// it also provides ! and short-circuited &&, || for better readability in more complicated comparisons
	console.log("VT." `${v1} == ${v3} || !(${v2} == ${v3} && ${v1} != ${v2})`);
	// although it is less performant than using direct JS logical operations, like so:
	console.log("VT." `${v1} == ${v3}` || !("VT." `!(${v2} == ${v3}` && "VT." `${v1} != ${v2})`));

	// also, for the same purpose it supports assignment operation:
	if ("VT." `(${v3} = ${v1}) != ${v2}`) console.log("v3 is set to new value that is not equal to v2");
});
```

Any of `New`, `From`, `Schema`, and `$` can be set to null or false to not expose tags for these particular items in the QS-wrapped code.

#LP } <-#./quadsugar-bonus#>

#LP ./reference { <#./%title: Reference#> <#./%order: 7#>

Reference to the VT API.

#LP ./ValueType { <#./%title: ValueType#>

VT's main namespace. In browser, it is always put under `ValueType` global variable name. In Node.js, it is directly the import from `require('quadsugar/valuetype')` which can be assigned
to any symbol, or destructured.

#LP ./Schema %member { <#./%title: Schema#>
String template tag for constructing a standalone destructuring schema. See <#ref reference/schema-grammar#> for more insight into the schema grammar.
`:`, `,` and `...` punctuators are ignored, and only used for readability.

```
const schXYA = ValueType.Schema `{ x, y, a: [0, 1] }`;
var valXYA = schXYA.fromValue({ x: 1, y: { text: "non-VTO" }, a["blah", null] });

// a schema can reference another ("external") schema for one of its members
const schWithNestedSchema = ValueType.Schema `[0, 1: @${schXYA}]`;
var valNested = schWithNestedSchema.fromValue([100, valXYA]);
```

Result of ``ValueType.Schema `...` `` is schema instance object, whose methods are described below.

#LP ./fromValue %method %member { <#./%title: .fromValue(value) [Schema instance]#>
Constructs VTO from the given value destructured per this schema. The value, or any of its deeper level members, does not have to be a VTO, but it must fit the schema (see <#ref ../fits#>),
otherwise runtime error will occur.

#LP value %arg: The source value to destructure. Should be an object that fits the schema.
#LP ./%return: The resulting VTO
#LP ./%errors: `ReferenceError` (in most cases) if the value provided does not fit the schema. A limited mismatch (absence of member from a terminal schema node in the source value) may
result in no error and setting this member to `undefined` instead, but deeper level mismatches will fail.
#LP } <-#./fromValue#>

#LP ./fits %method %member { <#./%title: .fits(value) [Schema instance]#>
Checks whether the given value fits the schema, that is, it can be safely and meaningfully destructured via the schema's <#ref ../fromValue#> method.
The schema defines the required set of members, and only these members will go into the resulting VTO after the value destructuring. The value can have extra members that are not mentioned in the schema -
such ones will be ignored on destructuring and are not counted when checking the fitting.

#LP ./value %arg: The value to check. It does not have to be an object, but for non-objects the check result is always false.
#LP ./%return: true if the value fits the schema, false otherwise
#LP } <-#./fits#>

#LP } <-#./Schema#>

#LP ./New %member %member { <#./%title: New#>
String template tag for creating a new VTO using inline set schema. See <#ref reference/schema-grammar#> for more insight into the schema grammar.
`:`, `,` and `...` punctuators are ignored, and only used for readability.

```
// all of these three yield equal VTOs
var xy = ValueType.New `{ x: ${1}, y: ${2} }`,
	xy2 = ValueType.New `{ y: ${2}, x: ${1} }`,
	xy3 = ValueType.New `@{x,y}: ...${{ x: 1, y: 2 }}`;

// note that empty array and empty object are NOT value-type equal
var emptyObject = ValueType.New `{}`,
	emptyArray = ValueType.New `[]`;
```

Result of ``ValueType.New `...` `` is the constructed VTO (array-type or object-type, depending on the rootmost brackets type). By itself, there objects have no other properties than actual data keys
(and also some standard technical, like `toString` (unless overridden by a data key), or `length` and array stuff for array-type VTO), the operations on them are implemented as static methods in `ValueType`
namespace.

#LP } <-#./New#>

#LP ./From %member { <#./%title: From(vto)#>
String template tag for creating a new VTO based on an existing VTO using inline edit schema. See <#ref reference/schema-grammar#> for more insight into the schema grammar.
`:`, `,` and `...` punctuators are ignored, and only used for readability.

```
var xy = ValueType.New `{ x: ${1}, y: ${2} }`,
	xy2 = ValueType.From(xy) `+{ y: ${3} }`,
	xy3 = ValueType.New `{ x: ${1}, y: ${3} }`; // equal to xy2

// deleting and adding keys is also possible
var xz = ValueType.From(xy) `+{ -y, z: ${3}}`; // { x: 1, z: 3 }
```

Result of ``ValueType.From(sourceVal) `...` `` is the _new_ VTO constructed from the source VTO by applying the modifications according to edit schema.
#LP ./vto %arg: The source value to base on, must be a VTO

#LP } <-#./From#>

#LP ./equals %method %member { <#./%title: .equals(v1, v2)#>
Check two given values for value-type equality. Use instead of standard JS `==` to correctly compare values that may be VTOs.
Non-VTO objects are only value-type equal if they equal in JS `===` sense.

#LP ./v1 %arg: First value to compare
#LP ./v2 %arg: Second value to compare
#LP ./%return: true if `v1` and `v2` are value-type equal, false otherwise
#LP } <-#./equals#>

#LP ./comparator %method %member { <#./%title: .comparator(v1, v2 [, differNonVto])#>
Compare two given values from perspective of their ordeting. The ordering is consistent within same JS session, but not persistent between different JS sessions.
Non-VTO objects are considered order-equal, unless you specify `differNonVto` parameter.

#LP ./v1 %arg: First value to compare
#LP ./v2 %arg: Second value to compare
#LP ./differNonVto %arg: Bool, optional (default = false). If false, then non-VTO objects are considered 'equal'. If you need strict total ordering, specify this parameter to be `true`, but
keep in mind that such comparison is more expensive and adds some memory overhead.
#LP ./%return: an integer: negative if `v1` is 'less than' `v2`, positive if `v1` is 'greater than' `v2`, zero if `v1` is 'equal' to `v2` (according to `differNonVto` mode)

#LP } <-#./comparator#>

#LP ./isValue %method %member { <#./%title: .isValue(v)#>
Check if a given value is value-type. Returns true for primitives and VTOs.
#LP ./v %arg: The value to check
#LP ./%return: true for primitives and VTOs, false for non-VTO objects and functions
#LP } <-#./isValue#>

#LP ./isValueTypeObject %method %member { <#./%title: .isValueTypeObject(v)#>
Check if a given value is a VTO.
#LP ./v %arg: The value to check
#LP ./%return: true if `v` is a non-null and is a VTO, false otherwise
#LP } <-#./isValueTypeObject#>

#LP ./MapVTK %member { <#./%title: MapVTK#>
A drop-in replacement to standard JS `Map` that uses value-type equality rules for key comparison. `VTK` means "value-type keys", to specifically indicate the difference from standard `Map`.

`MapVTK` interface is the same as of standard `Map` (as per ES 2019), with some extra methods.

#LP ./constructor %method %member { <#./%title: MapVTK([iterable])#>
Construct an instance of `MapVTK`. Can be used with `new` or as a plain function.

```
var map = new ValueType.MapVTK();
var map2 = ValueType.MapVTK();

console.log(map instanceof ValueType.MapVTK); // true
console.log(map2 instanceof ValueType.MapVTK); // true

map.set(1, "one");
map.set(ValueType.New `{ x: ${1}, y: ${2} }`, "x-one-y-two");
console.log(map.get(1));
console.log(map.get(ValueType.New `{ y: ${2}, x: ${1} }`));
```

#arg ./iterable %arg: An iterable of two-element arrays, optional. Each element is intrpreted as `[key, value]`. The collection to populate the new map with.
May, in particular, be an instance of `Map` or `MapVTK`.
#LP } <-#./constructor#>

#LP ./get %method %member { <#./%title: .get(key)#>
Get value from the map associated with the given key.
#LP ./key %arg: The key to search, using value-type equality
#LP ./%return: The value associated with the key, `undefined` if no equal key exists in the map
#LP } <-#./get#>

#LP ./set %method %member { <#./%title: .set(key, value)#>
Set (or replace existing) value in the map to associate with the given key.
#LP ./key %arg: The key to set or replace, using value-type equality
#LP ./value %arg: The value to associate with the key
#LP ./%return: The current instance of `MapVTK` itself
#LP } <-#./set#>

#LP ./replace %method %member { <#./%title: .replace(key, value)#>
Set (or replace existing) value in the map to associate with the given key. Unlike <#ref ../set#>, it returns previously associated value rather than the map instance,
so you can use it for an 'exchange value' operation.
#LP ./key %arg: The key to set or replace, using value-type equality
#LP ./value %arg: The value to associate with the key
#LP ./%return: The previously associated value, `undefined` if there was none
#LP } <-#./replace#>

#LP ./delete %method %member { <#./%title: .delete(key)#>
Delete a value in the map associated with the given key, if any exists.
#LP ./key %arg: The key to search, using value-type equality
#LP ./%return: true if the key existed and was actually deleted, false otherwise
#LP } <-#./delete#>

#LP ./remove %method %member { <#./%title: .remove(key)#>
Delete a value in the map associated with the given key, if any exists. Unlike <#ref ../delete#>, it returns the removed value rather than the map instance,
so you can use it for a 'pop' operation.
#LP ./key %arg: The key to search, using value-type equality
#LP ./%return: The removed value if one existed in the map, `undefined` otherwise
#LP } <-#./remove#>

#LP ./clear %method %member { <#./%title: .clear()#>
Clear all entries from the map.
#LP } <-#./clear#>

#LP ./setAll %method %member { <#./%title: .setAll([keyValuePairsIterable])#>
Add all elements into the map from the given iterable, treating its elements as key-value pairs. Existing elements with same keys will be replaced.

This is similar to what constructor of `MapVTK` with non-blank argument does, but allows to add (or replace) elements to already existing map at any later time.
#LP ./keyValuePairsIterable %arg: An iterable of 2-element arrays, which are treated as `[key, value]` pairs.
#LP ./%return: The current instance of `MapVTK` itself
#LP } <-#./setAll#>

#LP ./forEach %method %member { <#./%title: .forEach(callable [, thisObj])#>
Invoke the given function for every existing entry, in the enumeration order.

__Note__: `forEach` method is only present to be compliant with standard `Map` interface, but its use is strongly deprecated. Existence of this item has absolutely no rationale other than pure FAPCC.
`for...of` statement is around in JS for a very long time, and there is not a single sound reason to not using it instead of `forEach`.
#LP ./callable %arg: A function. It is supposed to take the arguments in the order: `(value, key, thisInstanceOfMapVTK)`. If `thisObj` is supplied, it is invoked as a method of `thisObj`.
#LP ./thisObj %arg: An object, optional. The object to bind `callable` to.
#LP } <-#./forEach#>

#LP ./size %property %member { <#./%title: .size#>
Number (integer). The number of entries currently in the map.
#LP } <-#./size#>

#LP ./keys %method %member { <#./%title: .keys()#>
Returns iterator over the keys in the map. The iteration is in chronological order of the keys insertion (newer keys go later, replacement of an existing key does not change its order).
#LP ./%return: Iterator. Each value returned by it is a key in the map.
#LP } <-#./keys#>

#LP ./values %method %member { <#./%title: .values()#>
Returns iterator over the values in the map. The iteration is in chronological order of the keys insertion (values for newer keys go later, replacement of an existing key does not change its order).
#LP ./%return: Iterator. Each value returned by it is a value in the map.
#LP } <-#./values#>

#LP ./entries %method %member { <#./%title: .entries()#>
Returns iterator over the entries in the map. The iteration is in chronological order of the keys insertion (values for newer keys go later, replacement of an existing key does not change its order).
Entries are yielded as `[key, value]` arrays.
#LP ./%return: Iterator. Each value returned by it is a `[key, value]` array, containing a key-value pair from the map.
#LP } <-#./entries#>

#LP ./[iterator] %property %member { <#./%title: [Symbol.iterator]#>
Returns iterator over the entries in the map, same as <#ref ../entries#>. To be used via `for..of` statement or by any other use of the `MapVTK` instance as an iterable.
#LP ./%return: Iterator. Each value returned by it is a `[key, value]` array, containing a key-value pair from the map.
#LP } <-#./[iterator]#>

#LP ./[toStringTag] %property %member { <#./%title: [Symbol.toStringTag]#>
Returns `"MapVTK"`.
#LP ./%return: "MapVTK" string
#LP } <-#./[toStringTag]#>

#LP } <-#./MapVTK#>

#LP ./quadsugarTags %method %member { <#./%title: .quadsugarTags(qsNSO [, tagsDict])#>
Creates dictionary of VT support static tags for Quadsugar's `.useStaticTags`. An example of use:
```
QUADSUGAR.useStaticTags({
	...ValueType.quadsugarTags(QUADSUGAR, {
		New: "VT.New",
		$: "VT."
	})
})
.wrap(() => {
	console.log("VT.New" `{ x: ${1}, y: ${2} }`);
	console.log("VT." `${"VT.New" `[${100}, ${500}]`} == ${"VT.New" `[0: ${100}, 1: ${500}]`}`);
});
```
#LP ./qsNSO %arg: The Quadsugar namespace value (should be `QUADSUGAR` in a browser environment).
#LP ./tagsDict %arg {
Dictionary of tags to use in the QS wrapped code for various VT features. Keys are feature identifiers (mostly match the tag function names from `ValueType` namespace), the values are
the tag names to assign to. Omitting a key will set the associated tag to default name, setting it to a null/false value will disable tag for this feature. The `tagsDict` argument can be omitted altogether,
which is the same as letting all tags be assigned as by default.
#LP ./Schema %property: Name for QS static tag that mirrors `ValueType.Schema` (and has same usage syntax). Default is `VT.Schema`.
#LP ./New %property: Name for QS static tag that mirrors `ValueType.New` (and has same usage syntax). Default is `VT.New`.
#LP ./From %property: Name for QS static tag that mirrors `ValueType.From` (and has same usage syntax). Default is `VT.From`.
#LP ./From %property: Name for QS static tag that provides VT's custom algebra for value-type equality and unequality comparison. By default this tag is disabled.

#LP The VT algebra supports the following operators, behaving and prioritized in same logic JS counterparts: `==` (value-type equality), `!=` (value-type unequality), `&&` (short-circuit logical AND & OR),
`||` (short-circuit logical OR), `!` (logical NOT), `=` (assignment)
#LP } <-#./tagsDict#>
#LP } <-#./quadsugarTags#>

#LP } <-#./ValueType#>

#LP ./schema-grammar { <#./%title: Schema literals grammar#>

This chapter gives some detailed insight into the schema literals grammar used in `New`, `From`, and `Schema`.

Lexical elements:
- C/JS-style comments: single line (`// ...<eol>`) and multi-line (`/* ... */`)
- whitespaces
- non-negative integer numbers
- C/JS-style single and double-quoted string constants,
- identifiers (anything that is valid as a JS identifier) - treated as string constants, so `a`, `"a"` and `'a'` are the same,
- punctuators: `+ - [ ] { } : , .@ ...`,
- inline placeholder (`${...JS expression...}`).

Comments, whitespaces and punctuators `: , ...` are ignored.

Syntax:
```
SCHEMA ::= ARRAY_SCHEMA | OBJECT_SCHEMA | EXT_SCHEMA
OBJECT_SCHEMA ::= '{' SCHEMA_IDX* '}'
ARRAY_SCHEMA ::= '[' SCHEMA_IDX* ']'
EXT_SCHEMA ::= '@' placeholder
SCHEMA_IDX ::= IDX SCHEMA?
IDX ::= IDSTRING | IDNUMBER
SET ::= SET_ARRAY | SET_OBJECT | SET_ARRAY_SEQ | SET_SCHEMA
SET_ARRAY ::= '[' SET_IDX* ']'
SET_OBJECT ::= '{' SET_IDX* '}'
SET_ARRAY_SEQ ::= '[' SET_VALUE* ']'
SET_SCHEMA ::= '@' SET_SCHEMA_SCHEMA placeholder
SET_SCHEMA_SCHEMA ::= placeholder | OBJECT_SCHEMA | ARRAY_SCHEMA
SET_IDX ::= IDX SET_VALUE
SET_VALUE ::= placeholder | SET
EDIT_ARRAY ::= '+' '[' MODIFY_IDX* ']'
EDIT_OBJECT ::= '+' '{' MODIFY_IDX* '}'
MODIFY_IDX ::= DELETE_IDX | SET_IDX | EDIT_IDX
DELETE_IDX ::= '-' IDX
EDIT_IDX ::= IDX EDIT_VALUE
EDIT_VALUE ::= EDIT_ARRAY | EDIT_OBJECT
```

The literal tags parse their inputs as the following symbols:
- `New`: `SET`
- `From`: `EDIT_ARRAY` | `EDIT_OBJECT`
- `Schema`: `SCHEMA`

Note that, although it is technically possible to use numeric keys in object-type schema and string/id keys in array-type schema, this is not allowed, and attempt to use
such a schema will be considered a syntax error.

#LP } <-#./schema-grammar#>

#LP } <-#./reference#>

#LP } <-#M/main-doc#>